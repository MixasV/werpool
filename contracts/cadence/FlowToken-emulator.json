{"address":"0ae53cb6e3f42a79","balance":"0.00100000","code":{"FlowToken":"import FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleTokenMetadataViews from 0xee82856bf20e2aa6\n\naccess(all) contract FlowToken: FungibleToken {\n\n    // Total supply of Flow tokens in existence\n    access(all) var totalSupply: UFix64\n\n    // Event that is emitted when tokens are withdrawn from a Vault\n    access(all) event TokensWithdrawn(amount: UFix64, from: Address?)\n\n    // Event that is emitted when tokens are deposited to a Vault\n    access(all) event TokensDeposited(amount: UFix64, to: Address?)\n\n    // Event that is emitted when new tokens are minted\n    access(all) event TokensMinted(amount: UFix64)\n\n    // Event that is emitted when a new minter resource is created\n    access(all) event MinterCreated(allowedAmount: UFix64)\n\n    // Event that is emitted when a new burner resource is created\n    access(all) event BurnerCreated()\n\n    // Vault\n    //\n    // Each user stores an instance of only the Vault in their storage\n    // The functions in the Vault and governed by the pre and post conditions\n    // in FungibleToken when they are called.\n    // The checks happen at runtime whenever a function is called.\n    //\n    // Resources can only be created in the context of the contract that they\n    // are defined in, so there is no way for a malicious user to create Vaults\n    // out of thin air. A special Minter resource needs to be defined to mint\n    // new tokens.\n    //\n    access(all) resource Vault: FungibleToken.Vault {\n\n        // holds the balance of a users tokens\n        access(all) var balance: UFix64\n\n        // initialize the balance at resource creation time\n        init(balance: UFix64) {\n            self.balance = balance\n        }\n\n        /// Called when a fungible token is burned via the `Burner.burn()` method\n        access(contract) fun burnCallback() {\n            if self.balance \u003e 0.0 {\n                FlowToken.totalSupply = FlowToken.totalSupply - self.balance\n            }\n            self.balance = 0.0\n        }\n\n        /// getSupportedVaultTypes optionally returns a list of vault types that this receiver accepts\n        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {\n            return {self.getType(): true}\n        }\n\n        access(all) view fun isSupportedVaultType(type: Type): Bool {\n            if (type == self.getType()) { return true } else { return false }\n        }\n\n        /// Asks if the amount can be withdrawn from this vault\n        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool {\n            return amount \u003c= self.balance\n        }\n\n        // withdraw\n        //\n        // Function that takes an integer amount as an argument\n        // and withdraws that amount from the Vault.\n        // It creates a new temporary Vault that is used to hold\n        // the money that is being transferred. It returns the newly\n        // created Vault to the context that called so it can be deposited\n        // elsewhere.\n        //\n        access(FungibleToken.Withdraw) fun withdraw(amount: UFix64): @{FungibleToken.Vault} {\n            self.balance = self.balance - amount\n\n            // If the owner is the staking account, do not emit the contract defined events\n            // this is to help with the performance of the epoch transition operations\n            // Either way, event listeners should be paying attention to the \n            // FungibleToken.Withdrawn events anyway because those contain\n            // much more comprehensive metadata\n            // Additionally, these events will eventually be removed from this contract completely\n            // in favor of the FungibleToken events\n            if let address = self.owner?.address {\n                if address != 0xf8d6e0586b0a20c7 \u0026\u0026\n                   address != 0xf4527793ee68aede \u0026\u0026\n                   address != 0x9eca2b38b18b5dfe \u0026\u0026\n                   address != 0x8624b52f9ddcd04a \n                {\n                    emit TokensWithdrawn(amount: amount, from: address)\n                }\n            } else {\n                emit TokensWithdrawn(amount: amount, from: nil)\n            }\n            return \u003c-create Vault(balance: amount)\n        }\n\n        // deposit\n        //\n        // Function that takes a Vault object as an argument and adds\n        // its balance to the balance of the owners Vault.\n        // It is allowed to destroy the sent Vault because the Vault\n        // was a temporary holder of the tokens. The Vault's balance has\n        // been consumed and therefore can be destroyed.\n        access(all) fun deposit(from: @{FungibleToken.Vault}) {\n            let vault \u003c- from as! @FlowToken.Vault\n            self.balance = self.balance + vault.balance\n\n            // If the owner is the staking account, do not emit the contract defined events\n            // this is to help with the performance of the epoch transition operations\n            // Either way, event listeners should be paying attention to the \n            // FungibleToken.Deposited events anyway because those contain\n            // much more comprehensive metadata\n            // Additionally, these events will eventually be removed from this contract completely\n            // in favor of the FungibleToken events\n            if let address = self.owner?.address {\n                if address != 0xf8d6e0586b0a20c7 \u0026\u0026\n                   address != 0xf4527793ee68aede \u0026\u0026\n                   address != 0x9eca2b38b18b5dfe \u0026\u0026\n                   address != 0x8624b52f9ddcd04a \n                {\n                    emit TokensDeposited(amount: vault.balance, to: address)\n                }\n            } else {\n                emit TokensDeposited(amount: vault.balance, to: nil)\n            }\n            vault.balance = 0.0\n            destroy vault\n        }\n\n        /// Get all the Metadata Views implemented by FlowToken\n        ///\n        /// @return An array of Types defining the implemented views. This value will be used by\n        ///         developers to know which parameter to pass to the resolveView() method.\n        ///\n        access(all) view fun getViews(): [Type]{\n            return FlowToken.getContractViews(resourceType: nil)\n        }\n\n        /// Get a Metadata View from FlowToken\n        ///\n        /// @param view: The Type of the desired view.\n        /// @return A structure representing the requested view.\n        ///\n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            return FlowToken.resolveContractView(resourceType: nil, viewType: view)\n        }\n\n        access(all) fun createEmptyVault(): @{FungibleToken.Vault} {\n            return \u003c-create Vault(balance: 0.0)\n        }\n    }\n\n    // createEmptyVault\n    //\n    // Function that creates a new Vault with a balance of zero\n    // and returns it to the calling context. A user must call this function\n    // and store the returned Vault in their storage in order to allow their\n    // account to be able to receive deposits of this token type.\n    //\n    access(all) fun createEmptyVault(vaultType: Type): @FlowToken.Vault {\n        return \u003c-create Vault(balance: 0.0)\n    }\n\n    /// Gets a list of the metadata views that this contract supports\n    access(all) view fun getContractViews(resourceType: Type?): [Type] {\n        return [Type\u003cFungibleTokenMetadataViews.FTView\u003e(),\n                Type\u003cFungibleTokenMetadataViews.FTDisplay\u003e(),\n                Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e(),\n                Type\u003cFungibleTokenMetadataViews.TotalSupply\u003e()]\n    }\n\n    /// Get a Metadata View from FlowToken\n    ///\n    /// @param view: The Type of the desired view.\n    /// @return A structure representing the requested view.\n    ///\n    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {\n        switch viewType {\n            case Type\u003cFungibleTokenMetadataViews.FTView\u003e():\n                return FungibleTokenMetadataViews.FTView(\n                    ftDisplay: self.resolveContractView(resourceType: nil, viewType: Type\u003cFungibleTokenMetadataViews.FTDisplay\u003e()) as! FungibleTokenMetadataViews.FTDisplay?,\n                    ftVaultData: self.resolveContractView(resourceType: nil, viewType: Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e()) as! FungibleTokenMetadataViews.FTVaultData?\n                )\n            case Type\u003cFungibleTokenMetadataViews.FTDisplay\u003e():\n                let media = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                        url: FlowToken.getLogoURI()\n                    ),\n                    mediaType: \"image/svg+xml\"\n                )\n                let medias = MetadataViews.Medias([media])\n                return FungibleTokenMetadataViews.FTDisplay(\n                    name: \"FLOW Network Token\",\n                    symbol: \"FLOW\",\n                    description: \"FLOW is the native token for the Flow blockchain. It is required for securing the network, transaction fees, storage fees, staking, FLIP voting and may be used by applications built on the Flow Blockchain\",\n                    externalURL: MetadataViews.ExternalURL(\"https://flow.com\"),\n                    logos: medias,\n                    socials: {\n                        \"twitter\": MetadataViews.ExternalURL(\"https://twitter.com/flow_blockchain\")\n                    }\n                )\n            case Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e():\n                let vaultRef = FlowToken.account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n\t\t\t        ?? panic(\"Could not borrow reference to the contract's Vault!\")\n                return FungibleTokenMetadataViews.FTVaultData(\n                    storagePath: /storage/flowTokenVault,\n                    receiverPath: /public/flowTokenReceiver,\n                    metadataPath: /public/flowTokenBalance,\n                    receiverLinkedType: Type\u003c\u0026{FungibleToken.Receiver, FungibleToken.Vault}\u003e(),\n                    metadataLinkedType: Type\u003c\u0026{FungibleToken.Balance, FungibleToken.Vault}\u003e(),\n                    createEmptyVaultFunction: (fun (): @{FungibleToken.Vault} {\n                        return \u003c-vaultRef.createEmptyVault()\n                    })\n                )\n            case Type\u003cFungibleTokenMetadataViews.TotalSupply\u003e():\n                return FungibleTokenMetadataViews.TotalSupply(totalSupply: FlowToken.totalSupply)\n        }\n        return nil\n    }\n\n    access(all) resource Administrator {\n        // createNewMinter\n        //\n        // Function that creates and returns a new minter resource\n        //\n        access(all) fun createNewMinter(allowedAmount: UFix64): @Minter {\n            emit MinterCreated(allowedAmount: allowedAmount)\n            return \u003c-create Minter(allowedAmount: allowedAmount)\n        }\n    }\n\n    // Minter\n    //\n    // Resource object that token admin accounts can hold to mint new tokens.\n    //\n    access(all) resource Minter {\n\n        // the amount of tokens that the minter is allowed to mint\n        access(all) var allowedAmount: UFix64\n\n        // mintTokens\n        //\n        // Function that mints new tokens, adds them to the total supply,\n        // and returns them to the calling context.\n        //\n        access(all) fun mintTokens(amount: UFix64): @FlowToken.Vault {\n            pre {\n                amount \u003e UFix64(0): \"Amount minted must be greater than zero\"\n                amount \u003c= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            FlowToken.totalSupply = FlowToken.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return \u003c-create Vault(balance: amount)\n        }\n\n        init(allowedAmount: UFix64) {\n            self.allowedAmount = allowedAmount\n        }\n    }\n\n    /// Gets the Flow Logo XML URI from storage\n    access(all) view fun getLogoURI(): String {\n        return FlowToken.account.storage.copy\u003cString\u003e(from: /storage/flowTokenLogoURI) ?? \"\"\n    }\n\n    init(adminAccount: auth(Storage, Capabilities) \u0026Account) {\n        self.totalSupply = 0.0\n\n        // Create the Vault with the total supply of tokens and save it in storage\n        //\n        let vault \u003c- create Vault(balance: self.totalSupply)\n\n        adminAccount.storage.save(\u003c-vault, to: /storage/flowTokenVault)\n\n        // Create a public capability to the stored Vault that only exposes\n        // the `deposit` method through the `Receiver` interface\n        //\n        let receiverCapability = adminAccount.capabilities.storage.issue\u003c\u0026FlowToken.Vault\u003e(/storage/flowTokenVault)\n        adminAccount.capabilities.publish(receiverCapability, at: /public/flowTokenReceiver)\n\n        // Create a public capability to the stored Vault that only exposes\n        // the `balance` field through the `Balance` interface\n        //\n        let balanceCapability = adminAccount.capabilities.storage.issue\u003c\u0026FlowToken.Vault\u003e(/storage/flowTokenVault)\n        adminAccount.capabilities.publish(balanceCapability, at: /public/flowTokenBalance)\n\n        let admin \u003c- create Administrator()\n        adminAccount.storage.save(\u003c-admin, to: /storage/flowTokenAdmin)\n\n    }\n}\n"},"contracts":["FlowToken"],"keys":["da3c2cc7fe43b280bc1fde4b297a57b0b2e8521c95c45c404fdf2d2cd3fe04a6a1c76168376304c4f9d7bf7e2b33600265825e7123dc1eae55a4e07501cfdb6a"]}