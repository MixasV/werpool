{"address":"ee82856bf20e2aa6","balance":"0.00100000","code":{"FlowExecutionParameters":"/// FlowExecutionParameters stores the parameters for metering\n/// transaction fees for Flow transactions\n\naccess(all) contract FlowExecutionParameters {\n\t\t\t\t\n    // Gets Execution Effort Weights from the parameters account's storage\n    access(all) view fun getExecutionEffortWeights(): {UInt64: UInt64} {\n        return self.account.storage.copy\u003c{UInt64: UInt64}\u003e(from: /storage/executionEffortWeights)\n            ?? panic(\"execution effort weights not set yet\")\n    }\n\n    // Gets Execution Memory Weights from the parameters account's storage\n    access(all) view fun getExecutionMemoryWeights(): {UInt64: UInt64} {\n        return self.account.storage.copy\u003c{UInt64: UInt64}\u003e(from: /storage/executionMemoryWeights)\n            ?? panic(\"execution memory weights not set yet\")\n    }\n\n    // Gets Execution Memory Limit from the parameters account's storage\n    access(all) view fun getExecutionMemoryLimit(): UInt64 {\n        return self.account.storage.copy\u003cUInt64\u003e(from: /storage/executionMemoryLimit)\n            ?? panic(\"execution memory limit not set yet\")\n    }\n}","FungibleToken":"/**\n\n# The Flow Fungible Token standard\n\n## `FungibleToken` contract\n\nIf a users wants to deploy a new token contract, their contract\nneeds to implement the FungibleToken interface and their tokens\nneed to implement the interfaces defined in this contract.\n\n/// Contributors (please add to this list if you contribute!):\n/// - Joshua Hannan - https://github.com/joshuahannan\n/// - Bastian MÃ¼ller - https://twitter.com/turbolent\n/// - Dete Shirley - https://twitter.com/dete73\n/// - Bjarte Karlsen - https://twitter.com/0xBjartek\n/// - Austin Kline - https://twitter.com/austin_flowty\n/// - Giovanni Sanchez - https://twitter.com/gio_incognito\n/// - Deniz Edincik - https://twitter.com/bluesign\n/// - Jonny - https://github.com/dryruner\n///\n/// Repo reference: https://github.com/onflow/flow-ft\n\n## `Vault` resource interface\n\nEach fungible token resource type needs to implement the `Vault` resource interface.\n\n## `Provider`, `Receiver`, and `Balance` resource interfaces\n\nThese interfaces declare pre-conditions and post-conditions that restrict\nthe execution of the functions in the Vault.\n\nIt gives users the ability to make custom resources that implement\nthese interfaces to do various things with the tokens.\nFor example, a faucet can be implemented by conforming\nto the Provider interface.\n\n*/\n\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport Burner from 0xf8d6e0586b0a20c7\n\n/// FungibleToken\n///\n/// Fungible Token implementations should implement the fungible token\n/// interface.\naccess(all) contract interface FungibleToken: ViewResolver {\n\n    // An entitlement for allowing the withdrawal of tokens from a Vault\n    access(all) entitlement Withdraw\n\n    /// The event that is emitted when tokens are withdrawn\n    /// from any Vault that implements the `Vault` interface\n    access(all) event Withdrawn(type: String,\n                                amount: UFix64,\n                                from: Address?,\n                                fromUUID: UInt64,\n                                withdrawnUUID: UInt64,\n                                balanceAfter: UFix64)\n\n    /// The event that is emitted when tokens are deposited to\n    /// any Vault that implements the `Vault` interface\n    access(all) event Deposited(type: String,\n                                amount: UFix64,\n                                to: Address?,\n                                toUUID: UInt64,\n                                depositedUUID: UInt64,\n                                balanceAfter: UFix64)\n\n    /// Event that is emitted when the global `Burner.burn()` method\n    /// is called with a non-zero balance\n    access(all) event Burned(type: String, amount: UFix64, fromUUID: UInt64)\n\n    /// Balance\n    ///\n    /// The interface that provides a standard field\n    /// for representing balance\n    ///\n    access(all) resource interface Balance {\n        access(all) var balance: UFix64\n    }\n\n    /// Provider\n    ///\n    /// The interface that enforces the requirements for withdrawing\n    /// tokens from the implementing type.\n    ///\n    /// It does not enforce requirements on `balance` here,\n    /// because it leaves open the possibility of creating custom providers\n    /// that do not necessarily need their own balance.\n    ///\n    access(all) resource interface Provider {\n\n        /// Function to ask a provider if a specific amount of tokens\n        /// is available to be withdrawn\n        /// This could be useful to avoid panicing when calling withdraw\n        /// when the balance is unknown\n        /// Additionally, if the provider is pulling from multiple vaults\n        /// it only needs to check some of the vaults until the desired amount\n        /// is reached, potentially helping with performance.\n        ///\n        /// @param amount the amount of tokens requested to potentially withdraw\n        /// @return Bool Whether or not this amount is available to withdraw\n        /// \n        access(all) view fun isAvailableToWithdraw(amount: UFix64): Bool\n\n        /// withdraw subtracts tokens from the implementing resource\n        /// and returns a Vault with the removed tokens.\n        ///\n        /// The function's access level is `access(Withdraw)`\n        /// So in order to access it, one would either need the object itself\n        /// or an entitled reference with `Withdraw`.\n        ///\n        /// @param amount the amount of tokens to withdraw from the resource\n        /// @return The Vault with the withdrawn tokens\n        ///\n        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {\n            post {\n                // `result` refers to the return value\n                result.balance == amount:\n                    \"FungibleToken.Provider.withdraw: Cannot withdraw tokens!\"\n                    .concat(\"The balance of the withdrawn tokens (\").concat(result.balance.toString())\n                    .concat(\") is not equal to the amount requested to be withdrawn (\")\n                    .concat(amount.toString()).concat(\")\")\n            }\n        }\n    }\n\n    /// Receiver\n    ///\n    /// The interface that enforces the requirements for depositing\n    /// tokens into the implementing type.\n    ///\n    /// We do not include a condition that checks the balance because\n    /// we want to give users the ability to make custom receivers that\n    /// can do custom things with the tokens, like split them up and\n    /// send them to different places.\n    ///\n    access(all) resource interface Receiver {\n\n        /// deposit takes a Vault and deposits it into the implementing resource type\n        ///\n        /// @param from the Vault that contains the tokens to deposit\n        ///\n        access(all) fun deposit(from: @{Vault})\n\n        /// getSupportedVaultTypes returns a dictionary of Vault types\n        /// and whether the type is currently supported by this Receiver\n        ///\n        /// @return {Type: Bool} A dictionary that indicates the supported types\n        ///                      If a type is not supported, it should be `nil`, not false\n        ///\n        access(all) view fun getSupportedVaultTypes(): {Type: Bool}\n\n        /// Returns whether or not the given type is accepted by the Receiver\n        /// A vault that can accept any type should just return true by default\n        ///\n        /// @param type The type to query about\n        /// @return Bool Whether or not the vault type is supported\n        ///\n        access(all) view fun isSupportedVaultType(type: Type): Bool\n    }\n\n    /// Vault\n    /// Conforms to all other interfaces so that implementations\n    /// only have to conform to `Vault`\n    ///\n    access(all) resource interface Vault: Receiver, Provider, Balance, ViewResolver.Resolver, Burner.Burnable {\n\n        /// Field that tracks the balance of a vault\n        access(all) var balance: UFix64\n\n        /// Called when a fungible token is burned via the `Burner.burn()` method\n        /// Implementations can do any bookkeeping or emit any events\n        /// that should be emitted when a vault is destroyed.\n        /// Many implementations will want to update the token's total supply\n        /// to reflect that the tokens have been burned and removed from the supply.\n        /// Implementations also need to set the balance to zero before the end of the function\n        /// This is to prevent vault owners from spamming fake Burned events.\n        access(contract) fun burnCallback() {\n            pre {\n                emit Burned(type: self.getType().identifier, amount: self.balance, fromUUID: self.uuid)\n            }\n            post {\n                self.balance == 0.0:\n                    \"FungibleToken.Vault.burnCallback: Cannot burn this Vault with Burner.burn(). \"\n                    .concat(\"The balance must be set to zero during the burnCallback method so that it cannot be spammed.\")\n            }\n            self.balance = 0.0\n        }\n\n        /// getSupportedVaultTypes\n        /// The default implementation is included here because vaults are expected\n        /// to only accepted their own type, so they have no need to provide an implementation\n        /// for this function\n        ///\n        access(all) view fun getSupportedVaultTypes(): {Type: Bool} {\n            // Below check is implemented to make sure that run-time type would\n            // only get returned when the parent resource conforms with `FungibleToken.Vault`. \n            if self.getType().isSubtype(of: Type\u003c@{FungibleToken.Vault}\u003e()) {\n                return {self.getType(): true}\n            } else {\n                // Return an empty dictionary as the default value for resource who don't\n                // implement `FungibleToken.Vault`, such as `FungibleTokenSwitchboard`, `TokenForwarder` etc.\n                return {}\n            }\n        }\n\n        /// Checks if the given type is supported by this Vault\n        access(all) view fun isSupportedVaultType(type: Type): Bool {\n            return self.getSupportedVaultTypes()[type] ?? false\n        }\n\n        /// withdraw subtracts `amount` from the Vault's balance\n        /// and returns a new Vault with the subtracted balance\n        ///\n        access(Withdraw) fun withdraw(amount: UFix64): @{Vault} {\n            pre {\n                self.balance \u003e= amount:\n                    \"FungibleToken.Vault.withdraw: Cannot withdraw tokens! \"\n                    .concat(\"The amount requested to be withdrawn (\").concat(amount.toString())\n                    .concat(\") is greater than the balance of the Vault (\")\n                    .concat(self.balance.toString()).concat(\").\")\n            }\n            post {\n                result.getType() == self.getType(): \n                    \"FungibleToken.Vault.withdraw: Cannot withdraw tokens! \"\n                    .concat(\"The withdraw method tried to return an incompatible Vault type \u003c\")\n                    .concat(result.getType().identifier).concat(\"\u003e. \")\n                    .concat(\"It must return a Vault with the same type as self \u003c\")\n                    .concat(self.getType().identifier).concat(\"\u003e.\")\n\n                // use the special function `before` to get the value of the `balance` field\n                // at the beginning of the function execution\n                //\n                self.balance == before(self.balance) - amount:\n                    \"FungibleToken.Vault.withdraw: Cannot withdraw tokens! \" \n                    .concat(\"The sender's balance after the withdrawal (\")\n                    .concat(self.balance.toString())\n                    .concat(\") must be the difference of the previous balance (\").concat(before(self.balance.toString()))\n                    .concat(\") and the amount withdrawn (\").concat(amount.toString()).concat(\")\")\n\n                emit Withdrawn(\n                        type: result.getType().identifier,\n                        amount: amount,\n                        from: self.owner?.address,\n                        fromUUID: self.uuid,\n                        withdrawnUUID: result.uuid,\n                        balanceAfter: self.balance\n                )\n            }\n        }\n\n        /// deposit takes a Vault and adds its balance to the balance of this Vault\n        ///\n        access(all) fun deposit(from: @{FungibleToken.Vault}) {\n            // Assert that the concrete type of the deposited vault is the same\n            // as the vault that is accepting the deposit\n            pre {\n                from.isInstance(self.getType()): \n                    \"FungibleToken.Vault.deposit: Cannot deposit tokens! \"\n                    .concat(\"The type of the deposited tokens \u003c\")\n                    .concat(from.getType().identifier)\n                    .concat(\"\u003e has to be the same type as the Vault being deposited into \u003c\")\n                    .concat(self.getType().identifier)\n                    .concat(\"\u003e. Check that you are withdrawing and depositing to the correct paths in the sender and receiver accounts \")\n                    .concat(\"and that those paths hold the same Vault types.\")\n            }\n            post {\n                emit Deposited(\n                        type: before(from.getType().identifier),\n                        amount: before(from.balance),\n                        to: self.owner?.address,\n                        toUUID: self.uuid,\n                        depositedUUID: before(from.uuid),\n                        balanceAfter: self.balance\n                )\n                self.balance == before(self.balance) + before(from.balance):\n                    \"FungibleToken.Vault.deposit: Cannot deposit tokens! \" \n                    .concat(\"The receiver's balance after the deposit (\")\n                    .concat(self.balance.toString())\n                    .concat(\") must be the sum of the previous balance (\").concat(before(self.balance.toString()))\n                    .concat(\") and the amount deposited (\").concat(before(from.balance).toString()).concat(\")\")\n            }\n        }\n\n        /// createEmptyVault allows any user to create a new Vault that has a zero balance\n        ///\n        /// @return A Vault of the same type that has a balance of zero\n        access(all) fun createEmptyVault(): @{Vault} {\n            post {\n                result.balance == 0.0:\n                    \"FungibleToken.Vault.createEmptyVault: Empty Vault creation failed! \"\n                    .concat(\"The newly created Vault must have zero balance but it has a balance of \")\n                    .concat(result.balance.toString())\n\n                result.getType() == self.getType():\n                    \"FungibleToken.Vault.createEmptyVault: Empty Vault creation failed! \"\n                    .concat(\"The type of the new Vault \u003c\")\n                    .concat(result.getType().identifier)\n                    .concat(\"\u003e has to be the same type as the Vault that created it \u003c\")\n                    .concat(self.getType().identifier)\n                    .concat(\"\u003e.\")\n            }\n        }\n    }\n\n    /// createEmptyVault allows any user to create a new Vault that has a zero balance\n    ///\n    /// @return A Vault of the requested type that has a balance of zero\n    access(all) fun createEmptyVault(vaultType: Type): @{FungibleToken.Vault} {\n        post {\n            result.balance == 0.0:\n                \"FungibleToken.createEmptyVault: Empty Vault creation failed! \"\n                .concat(\"The newly created Vault must have zero balance but it has a balance of (\")\n                .concat(result.balance.toString()).concat(\")\")\n\n            result.getType() == vaultType:\n                \"FungibleToken.Vault.createEmptyVault: Empty Vault creation failed! \"\n                .concat(\"The type of the new Vault \u003c\")\n                .concat(result.getType().identifier)\n                .concat(\"\u003e has to be the same as the type that was requested \u003c\")\n                .concat(vaultType.identifier)\n                .concat(\"\u003e.\")\n        }\n    }\n}","FungibleTokenMetadataViews":"import FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\n\n/// This contract implements the metadata standard proposed\n/// in FLIP-1087.\n/// \n/// Ref: https://github.com/onflow/flips/blob/main/application/20220811-fungible-tokens-metadata.md\n/// \n/// Structs and resources can implement one or more\n/// metadata types, called views. Each view type represents\n/// a different kind of metadata.\n///\naccess(all) contract FungibleTokenMetadataViews {\n\n    /// FTView wraps FTDisplay and FTVaultData, and is used to give a complete \n    /// picture of a Fungible Token. Most Fungible Token contracts should \n    /// implement this view.\n    ///\n    access(all) struct FTView {\n        access(all) let ftDisplay: FTDisplay?     \n        access(all) let ftVaultData: FTVaultData?\n        view init(\n            ftDisplay: FTDisplay?,\n            ftVaultData: FTVaultData?\n        ) {\n            self.ftDisplay = ftDisplay\n            self.ftVaultData = ftVaultData\n        }\n    }\n\n    /// Helper to get a FT view.\n    ///\n    /// @param viewResolver: A reference to the resolver resource\n    /// @return A FTView struct\n    ///\n    access(all) fun getFTView(viewResolver: \u0026{ViewResolver.Resolver}): FTView {\n        let maybeFTView = viewResolver.resolveView(Type\u003cFTView\u003e())\n        if let ftView = maybeFTView {\n            return ftView as! FTView\n        }\n        return FTView(\n            ftDisplay: self.getFTDisplay(viewResolver),\n            ftVaultData: self.getFTVaultData(viewResolver)\n        )\n    }\n\n    /// View to expose the information needed to showcase this FT. \n    /// This can be used by applications to give an overview and \n    /// graphics of the FT.\n    ///\n    access(all) struct FTDisplay {\n        /// The display name for this token.\n        ///\n        /// Example: \"Flow\"\n        ///\n        access(all) let name: String\n\n        /// The abbreviated symbol for this token.\n        ///\n        /// Example: \"FLOW\"\n        access(all) let symbol: String\n\n        /// A description the provides an overview of this token.\n        ///\n        /// Example: \"The FLOW token is the native currency of the Flow network.\"\n        access(all) let description: String\n\n        /// External link to a URL to view more information about the fungible token.\n        access(all) let externalURL: MetadataViews.ExternalURL\n\n        /// One or more versions of the fungible token logo.\n        access(all) let logos: MetadataViews.Medias\n\n        /// Social links to reach the fungible token's social homepages.\n        /// Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n        access(all) let socials: {String: MetadataViews.ExternalURL}\n\n        view init(\n            name: String,\n            symbol: String,\n            description: String,\n            externalURL: MetadataViews.ExternalURL,\n            logos: MetadataViews.Medias,\n            socials: {String: MetadataViews.ExternalURL}\n        ) {\n            self.name = name\n            self.symbol = symbol\n            self.description = description\n            self.externalURL = externalURL\n            self.logos = logos\n            self.socials = socials\n        }\n    }\n\n    /// Helper to get FTDisplay in a way that will return a typed optional.\n    /// \n    /// @param viewResolver: A reference to the resolver resource\n    /// @return An optional FTDisplay struct\n    ///\n    access(all) fun getFTDisplay(_ viewResolver: \u0026{ViewResolver.Resolver}): FTDisplay? {\n        if let maybeDisplayView = viewResolver.resolveView(Type\u003cFTDisplay\u003e()) {\n            if let displayView = maybeDisplayView as? FTDisplay {\n                return displayView\n            }\n        }\n        return nil\n    }\n\n    /// View to expose the information needed store and interact with a FT vault.\n    /// This can be used by applications to setup a FT vault with proper \n    /// storage and public capabilities.\n    ///\n    access(all) struct FTVaultData {\n        /// Path in storage where this FT vault is recommended to be stored.\n        access(all) let storagePath: StoragePath\n\n        /// Public path which must be linked to expose the public receiver capability.\n        access(all) let receiverPath: PublicPath\n\n        /// Public path which must be linked to expose the balance and resolver public capabilities.\n        access(all) let metadataPath: PublicPath\n\n        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring \n        /// the `FungibleToken.Receiver` interface.\n        access(all) let receiverLinkedType: Type\n\n        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring \n        /// the `ViewResolver.Resolver` interfaces.\n        access(all) let metadataLinkedType: Type\n\n        /// Function that allows creation of an empty FT vault that is intended\n        /// to store the funds.\n        access(all) let createEmptyVault: fun(): @{FungibleToken.Vault}\n\n        view init(\n            storagePath: StoragePath,\n            receiverPath: PublicPath,\n            metadataPath: PublicPath,\n            receiverLinkedType: Type,\n            metadataLinkedType: Type,\n            createEmptyVaultFunction: fun(): @{FungibleToken.Vault}\n        ) {\n            pre {\n                receiverLinkedType.isSubtype(of: Type\u003c\u0026{FungibleToken.Receiver}\u003e()):\n                    \"Receiver public type \u003c\".concat(receiverLinkedType.identifier)\n                    .concat(\"\u003e must be a subtype of \u003c\").concat(Type\u003c\u0026{FungibleToken.Receiver}\u003e().identifier)\n                    .concat(\"\u003e.\")\n                metadataLinkedType.isSubtype(of: Type\u003c\u0026{FungibleToken.Vault}\u003e()):\n                    \"Metadata linked type \u003c\".concat(metadataLinkedType.identifier)\n                    .concat(\"\u003e must be a subtype of \u003c\").concat(Type\u003c\u0026{FungibleToken.Vault}\u003e().identifier)\n                    .concat(\"\u003e.\")\n            }\n            self.storagePath = storagePath\n            self.receiverPath = receiverPath\n            self.metadataPath = metadataPath\n            self.receiverLinkedType = receiverLinkedType\n            self.metadataLinkedType = metadataLinkedType\n            self.createEmptyVault = createEmptyVaultFunction\n        }\n    }\n\n    /// Helper to get FTVaultData in a way that will return a typed Optional.\n    ///\n    /// @param viewResolver: A reference to the resolver resource\n    /// @return A optional FTVaultData struct\n    ///\n    access(all) fun getFTVaultData(_ viewResolver: \u0026{ViewResolver.Resolver}): FTVaultData? {\n        if let view = viewResolver.resolveView(Type\u003cFTVaultData\u003e()) {\n            if let v = view as? FTVaultData {\n                return v\n            }\n        }\n        return nil\n    }\n\n    /// View to expose the total supply of the Vault's token\n    access(all) struct TotalSupply {\n        access(all) let supply: UFix64\n\n        view init(totalSupply: UFix64) {\n            self.supply = totalSupply\n        }\n    }\n}\n ","FungibleTokenSwitchboard":"import FungibleToken from 0xee82856bf20e2aa6\n\n/// The contract that allows an account to receive payments in multiple fungible\n/// tokens using a single `{FungibleToken.Receiver}` capability.\n/// This capability should ideally be stored at the \n/// `FungibleTokenSwitchboard.ReceiverPublicPath = /public/GenericFTReceiver`\n/// but it can be stored anywhere.\n/// \naccess(all) contract FungibleTokenSwitchboard {\n  \n    // Storage and Public Paths\n    access(all) let StoragePath: StoragePath\n    access(all) let PublicPath: PublicPath\n    access(all) let ReceiverPublicPath: PublicPath\n\n    access(all) entitlement Owner\n\n    /// The event that is emitted when a new vault capability is added to a\n    /// switchboard resource.\n    /// \n    access(all) event VaultCapabilityAdded(type: Type, switchboardOwner: Address?, \n                                    capabilityOwner: Address?)\n\n    /// The event that is emitted when a vault capability is removed from a \n    /// switchboard resource.\n    /// \n    access(all) event VaultCapabilityRemoved(type: Type,  switchboardOwner: Address?, \n                                        capabilityOwner: Address?)\n\n    /// The event that is emitted when a deposit can not be completed.\n    /// \n    access(all) event NotCompletedDeposit(type: Type, amount: UFix64, \n                                    switchboardOwner: Address?)\n\n    /// The interface that enforces the method to allow anyone to check on the\n    /// available capabilities of a switchboard resource and also exposes the \n    /// deposit methods to deposit funds on it.\n    /// \n    access(all) resource interface SwitchboardPublic {\n        access(all) view fun getVaultTypesWithAddress(): {Type: Address}\n        access(all) view fun getSupportedVaultTypes(): {Type: Bool}\n        access(all) view fun isSupportedVaultType(type: Type): Bool\n        access(all) fun deposit(from: @{FungibleToken.Vault})\n        access(all) fun safeDeposit(from: @{FungibleToken.Vault}): @{FungibleToken.Vault}?\n        access(all) view fun safeBorrowByType(type: Type): \u0026{FungibleToken.Receiver}?\n    }\n\n    /// The resource that stores the multiple fungible token receiver \n    /// capabilities, allowing the owner to add and remove them and anyone to \n    /// deposit any fungible token among the available types.\n    /// \n    access(all) resource Switchboard: FungibleToken.Receiver, SwitchboardPublic {\n       \n        /// Dictionary holding the fungible token receiver capabilities, \n        /// indexed by the fungible token vault type.\n        /// \n        access(contract) var receiverCapabilities: {Type: Capability\u003c\u0026{FungibleToken.Receiver}\u003e}\n\n        /// Adds a new fungible token receiver capability to the switchboard \n        /// resource.\n        /// \n        /// @param capability: The capability to expose a certain fungible\n        /// token vault deposit function through `{FungibleToken.Receiver}` that\n        /// will be added to the switchboard.\n        /// \n        access(Owner) fun addNewVault(capability: Capability\u003c\u0026{FungibleToken.Receiver}\u003e) {\n            // Borrow a reference to the vault pointed to by the capability we \n            // want to store inside the switchboard\n            let vaultRef = capability.borrow() \n                ?? panic(\"FungibleTokenSwitchboard.Switchboard.addNewVault: Cannot borrow reference to vault from capability! \"\n                          .concat(\"Make sure that the capability path points to a Vault that has been properly initialized. \"))\n\n            // Check if there is a previous capability for this token\n            if (self.receiverCapabilities[vaultRef.getType()] == nil) {\n                // use the vault reference type as key for storing the \n                // capability and then\n                self.receiverCapabilities[vaultRef.getType()] = capability\n                // emit the event that indicates that a new capability has been \n                // added\n                emit VaultCapabilityAdded(type: vaultRef.getType(),\n                                               switchboardOwner: self.owner?.address, \n                                                 capabilityOwner: capability.address)\n            } else {\n                // If there was already a capability for that token, panic\n                panic(\"FungibleTokenSwitchboard.Switchboard.addNewVault: Cannot add new Vault capability! \"\n                    .concat(\"There is already a vault in the Switchboard for this type \u003c\")\n                    .concat(vaultRef.getType().identifier).concat(\"\u003e.\"))\n            }\n        }\n\n        /// Adds a number of new fungible token receiver capabilities by using\n        /// the paths where they are stored.\n        ///                    \n        /// @param paths: The paths where the public capabilities are stored.\n        /// @param address: The address of the owner of the capabilities.\n        /// \n        access(Owner) fun addNewVaultsByPath(paths: [PublicPath], address: Address) {\n            // Get the account where the public capabilities are stored\n            let owner = getAccount(address)\n            // For each path, get the saved capability and store it \n            // into the switchboard's receiver capabilities dictionary\n            for path in paths {\n                let capability = owner.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(path)\n                // Borrow a reference to the vault pointed to by the capability\n                // we want to store inside the switchboard\n                // If the vault was borrowed successfully...\n                if let vaultRef = capability.borrow() {\n                    // ...and if there is no previous capability added for that token\n                    if (self.receiverCapabilities[vaultRef!.getType()] == nil) {\n                        // Use the vault reference type as key for storing the\n                        // capability\n                        self.receiverCapabilities[vaultRef!.getType()] = capability\n                        // and emit the event that indicates that a new\n                        // capability has been added\n                        emit VaultCapabilityAdded(type: vaultRef.getType(),\n                            switchboardOwner: self.owner?.address,\n                            capabilityOwner: address,\n                        )\n                    }\n                }\n            }\n        }\n\n        /// Adds a new fungible token receiver capability to the switchboard \n        /// resource specifying which `Type` of `@{FungibleToken.Vault}` can be \n        /// deposited to it. Use it to include in your switchboard \"wrapper\"\n        /// receivers such as a `@TokenForwarding.Forwarder`. It can also be\n        /// used to overwrite the type attached to a certain capability without \n        /// having to remove that capability first.\n        ///\n        /// @param capability: The capability to expose a certain fungible\n        /// token vault deposit function through `{FungibleToken.Receiver}` that\n        /// will be added to the switchboard.\n        ///\n        /// @param type: The type of fungible token that can be deposited to that\n        /// capability, rather than the `Type` from the reference borrowed from\n        /// said capability\n        /// \n        access(Owner) fun addNewVaultWrapper(capability: Capability\u003c\u0026{FungibleToken.Receiver}\u003e, \n                                                                        type: Type) {\n            // Check if the capability is working\n            assert (\n                capability.check(),\n                message:\n                    \"FungibleTokenSwitchboard.Switchboard.addNewVaultWrapper: Cannot borrow reference to a vault from the provided capability! \"\n                    .concat(\"Make sure that the capability path points to a Vault that has been properly initialized.\")\n            )\n            // Use the type parameter as key for the capability\n            self.receiverCapabilities[type] = capability\n            // emit the event that indicates that a new capability has been \n            // added\n            emit VaultCapabilityAdded(\n                type: type,\n                switchboardOwner: self.owner?.address,\n                capabilityOwner: capability.address,\n            )\n        }\n\n        /// Adds zero or more new fungible token receiver capabilities to the  \n        /// switchboard resource specifying which `Type`s of `@{FungibleToken.Vault}`s  \n        /// can be deposited to it. Use it to include in your switchboard \"wrapper\"\n        /// receivers such as a `@TokenForwarding.Forwarder`. It can also be\n        /// used to overwrite the types attached to certain capabilities without \n        /// having to remove those capabilities first.\n        ///                    \n        /// @param paths: The paths where the public capabilities are stored.\n        /// @param types: The types of the fungible token to be deposited on each path.\n        /// @param address: The address of the owner of the capabilities.\n        /// \n        access(Owner) fun addNewVaultWrappersByPath(paths: [PublicPath], types: [Type], \n                                                                  address: Address) {\n            // Get the account where the public capabilities are stored\n            let owner = getAccount(address)\n            // For each path, get the saved capability and store it \n            // into the switchboard's receiver capabilities dictionary\n            for i, path in paths {\n                let capability = owner.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(path)\n                // Borrow a reference to the vault pointed to by the capability\n                // we want to store inside the switchboard\n                // If the vault was borrowed successfully...\n                if let vaultRef = capability.borrow() {\n                    // Use the vault reference type as key for storing the capability\n                    self.receiverCapabilities[types[i]] = capability\n                    // and emit the event that indicates that a new capability has been added\n                    emit VaultCapabilityAdded(\n                        type: types[i],\n                        switchboardOwner: self.owner?.address,\n                        capabilityOwner: address,\n                    )\n                }\n            }\n        }\n\n        /// Removes a fungible token receiver capability from the switchboard\n        /// resource.\n        /// \n        /// @param capability: The capability to a fungible token vault to be\n        /// removed from the switchboard.\n        /// \n        access(Owner) fun removeVault(capability: Capability\u003c\u0026{FungibleToken.Receiver}\u003e) {\n            // Borrow a reference to the vault pointed to by the capability we \n            // want to remove from the switchboard\n            let vaultRef = capability.borrow()\n                ?? panic (\"FungibleTokenSwitchboard.Switchboard.addNewVaultWrapper: Cannot borrow reference to a vault from the provided capability! \"\n                          .concat(\"Make sure that the capability path points to a Vault that has been properly initialized.\"))\n\n            // Use the vault reference to find the capability to remove\n            self.receiverCapabilities.remove(key: vaultRef.getType())\n            // Emit the event that indicates that a new capability has been \n            // removed\n            emit VaultCapabilityRemoved(\n                type: vaultRef.getType(),\n                switchboardOwner: self.owner?.address,\n                capabilityOwner: capability.address,\n            )\n        }\n        \n        /// Takes a fungible token vault and routes it to the proper fungible \n        /// token receiver capability for depositing it.\n        /// \n        /// @param from: The deposited fungible token vault resource.\n        /// \n        access(all) fun deposit(from: @{FungibleToken.Vault}) {\n            // Get the capability from the ones stored at the switchboard\n            let depositedVaultCapability = self.receiverCapabilities[from.getType()]\n                ?? panic (\"FungibleTokenSwitchboard.Switchboard.deposit: Cannot deposit Vault! \"\n                          .concat(\"The deposited vault of type \u003c\").concat(from.getType().identifier)\n                          .concat(\"\u003e is not available on this Fungible Token switchboard. \")\n                          .concat(\"The recipient needs to initialize their account and switchboard to hold and receive the deposited vault type.\"))\n\n            // Borrow the reference to the desired vault\n            let vaultRef = depositedVaultCapability.borrow()\n                ?? panic (\"FungibleTokenSwitchboard.Switchboard.deposit: Cannot borrow reference to a vault \"\n                          .concat(\"from the type of the deposited Vault \u003c\").concat(from.getType().identifier)\n                          .concat(\"\u003e. Make sure that the capability path points to a Vault that has been properly initialized.\"))\n\n            vaultRef.deposit(from: \u003c-from)\n        }\n\n        /// Takes a fungible token vault and tries to route it to the proper\n        /// fungible token receiver capability for depositing the funds, \n        /// avoiding panicking if the vault is not available.\n        ///             \n        /// @param vaultType: The type of the ft vault that wants to be \n        /// deposited.\n        /// \n        /// @return The deposited fungible token vault resource, without the\n        /// funds if the deposit was successful, or still containing the funds\n        /// if the reference to the needed vault was not found.\n        /// \n        access(all) fun safeDeposit(from: @{FungibleToken.Vault}): @{FungibleToken.Vault}? {\n            // Try to get the proper vault capability from the switchboard\n            // If the desired vault is present on the switchboard...\n            if let depositedVaultCapability = self.receiverCapabilities[from.getType()] {\n                // We try to borrow a reference to the vault from the capability\n                // If we can borrow a reference to the vault...\n                if let vaultRef = depositedVaultCapability.borrow() {\n                    // We deposit the funds on said vault\n                    vaultRef.deposit(from: \u003c-from.withdraw(amount: from.balance))\n                }\n            }\n            // if deposit failed for some reason\n            if from.balance \u003e 0.0 {\n                emit NotCompletedDeposit(\n                    type: from.getType(),\n                    amount: from.balance,\n                    switchboardOwner: self.owner?.address,\n                )\n                return \u003c-from\n            }\n            destroy from \n            return nil\n        }\n\n        /// Checks that the capability tied to a type is valid\n        ///\n        /// @param vaultType: The type of the ft vault whose capability needs to be checked\n        ///\n        /// @return a boolean marking the capability for a type as valid or not\n        access(all) view fun checkReceiverByType(type: Type): Bool {\n            if self.receiverCapabilities[type] == nil {\n                return false\n            }\n\n            return self.receiverCapabilities[type]!.check()\n        }\n\n        /// Gets the receiver assigned to a provided vault type.\n        /// This is necessary because without it, it is not possible to look under the hood and see if a capability\n        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid \n        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.\n        ///\n        /// @param vaultType: The type of the ft vault whose capability needs to be checked\n        ///\n        /// @return an optional receiver capability for consumers of the switchboard to check/validate on their own\n        access(all) view fun safeBorrowByType(type: Type): \u0026{FungibleToken.Receiver}? {\n            if !self.checkReceiverByType(type: type) {\n                return nil\n            }\n\n            return self.receiverCapabilities[type]!.borrow()\n        }\n\n        /// A getter function to know which tokens a certain switchboard \n        /// resource is prepared to receive along with the address where\n        /// those tokens will be deposited.\n        ///\n        /// @return A dictionary mapping the `{FungibleToken.Receiver}` \n        /// type to the receiver owner's address \n        ///\n        access(all) view fun getVaultTypesWithAddress(): {Type: Address} {\n            let effectiveTypesWithAddress: {Type: Address} = {}\n            // Check if each capability is live\n            for vaultType in self.receiverCapabilities.keys {\n                if self.receiverCapabilities[vaultType]!.check() {\n                    // and attach it to the owner's address\n                    effectiveTypesWithAddress[vaultType] = self.receiverCapabilities[vaultType]!.address\n                }\n            }\n            return effectiveTypesWithAddress\n        }\n\n        /// A getter function that returns the token types supported by this resource,\n        /// which can be deposited using the 'deposit' function.\n        ///\n        /// @return Dictionary of FT types that can be deposited.\n        access(all) view fun getSupportedVaultTypes(): {Type: Bool} { \n            let supportedVaults: {Type: Bool} = {}\n            for receiverType in self.receiverCapabilities.keys {\n                if self.receiverCapabilities[receiverType]!.check() {\n                    if receiverType.isSubtype(of: Type\u003c@{FungibleToken.Vault}\u003e()) {\n                        supportedVaults[receiverType] = true\n                    }\n                    if receiverType.isSubtype(of: Type\u003c@{FungibleToken.Receiver}\u003e()) {\n                        let receiverRef = self.receiverCapabilities[receiverType]!.borrow()!\n                        let subReceiverSupportedTypes = receiverRef.getSupportedVaultTypes()\n                        for subReceiverType in subReceiverSupportedTypes.keys {                          \n                            if subReceiverType.isSubtype(of: Type\u003c@{FungibleToken.Vault}\u003e()) {\n                                supportedVaults[subReceiverType] = true\n                            }\n                        }\n                    }\n                }\n            }\n            return supportedVaults\n        }\n\n        /// Returns whether or not the given type is accepted by the Receiver\n        /// A vault that can accept any type should just return true by default\n        access(all) view fun isSupportedVaultType(type: Type): Bool {\n            let supportedVaults = self.getSupportedVaultTypes()\n            if let supported = supportedVaults[type] {\n                return supported\n            } else { return false }\n        }\n\n        init() {\n            // Initialize the capabilities dictionary\n            self.receiverCapabilities = {}\n        }\n\n    }\n\n    /// Function that allows to create a new blank switchboard. A user must call\n    /// this function and store the returned resource in their storage.\n    ///\n    access(all) fun createSwitchboard(): @Switchboard {\n        return \u003c-create Switchboard()\n    }\n\n    init() {\n        self.StoragePath = /storage/fungibleTokenSwitchboard\n        self.PublicPath = /public/fungibleTokenSwitchboardPublic\n        self.ReceiverPublicPath = /public/GenericFTReceiver\n    }\n}\n"},"contracts":["FlowExecutionParameters","FungibleToken","FungibleTokenMetadataViews","FungibleTokenSwitchboard"],"keys":["da3c2cc7fe43b280bc1fde4b297a57b0b2e8521c95c45c404fdf2d2cd3fe04a6a1c76168376304c4f9d7bf7e2b33600265825e7123dc1eae55a4e07501cfdb6a"]}